diff --git a/contracts/SpectrrCore.sol b/contracts/SpectrrCore.sol
index fdc8bea..d730a48 100644
--- a/contracts/SpectrrCore.sol
+++ b/contracts/SpectrrCore.sol
@@ -14,12 +14,12 @@ import "./SpectrrUtils.sol";
     This contract does not allow selling/buying a token for the same token. 
     Also, the collateral token chosen in a buy offer can not be the same than the repayment token.
     For example, one could make the following buy offer:
-        Buy 1 BTC for 69,000$ (assuming a current BTC price of 68,500$), pledge 1.8 times the repayment amount in collateral (here, 1.8 BTC), 
+        Buy 1 BTC for 69,000$ (assuming a current BTC price of 68,500$), pledge 1.5 times the repayment amount in collateral (here, 1.5 BTC), 
         and specify a repayment period of 69 days. After that, let us say that that someone accepts the offer by sending 1 BTC to the buyer.
         Assuming that the price of BTC reaches 70,000$ when the debt is repaid,
         the buyer would then make a profit of 70,000$ - 69,000$ = 1000$, after selling the 1 BTC bought earlier.
         On the other hand, the seller will receive 69,000$, and would have made a profit of 69,000$ - 68,500$ = 500$.
-        It can be noted that in our case, the seller would have made more profit holding the BTC.
+        It can be noted that in our case, the seller would have made more profit just holding the BTC.
 */
 /** @custom:extra The contract was voluntarily made this way in order for it to align with the principles of Islamic finance.
     In the latter, some prohibitions include dealing with interest, 
@@ -54,9 +54,7 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
     ) external nonReentrant returns (uint256) {
         checkIsPositive(_sellingTokenAmountWei);
         checkIsPositive(_exchangeRateWei);
-        checkTokenIdInRange(_sellingTokenId);
-        checkTokenIdInRange(_sellingForTokenId);
-        checkTokenIdNotSame(_sellingForTokenId, _sellingTokenId);
+        checkTokensIdNotSame(_sellingForTokenId, _sellingTokenId);
 
         transferSenderToContract(
             msg.sender,
@@ -117,7 +115,7 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
 
         checkOfferIsOpen(offer.offerStatus);
         checkAddressNotSender(offer.seller);
-        checkTokenIdNotSame(_collateralTokenId, offer.sellingId);
+        checkTokensIdNotSame(_collateralTokenId, offer.sellingId);
 
         uint256 collateralTokenAmount = getCollateral(
             offer.sellingFor,
@@ -360,10 +358,8 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
     ) external nonReentrant returns (uint256) {
         checkIsPositive(_buyingTokenAmountWei);
         checkIsPositive(_exchangeRateWei);
-        checkTokenIdInRange(_buyingTokenId);
-        checkTokenIdInRange(_buyingForTokenId);
-        checkTokenIdNotSame(_buyingTokenId, _buyingForTokenId);
-        checkTokenIdNotSame(_collateralTokenId, _buyingTokenId);
+        checkTokensIdNotSame(_buyingTokenId, _buyingForTokenId);
+        checkTokensIdNotSame(_collateralTokenId, _buyingTokenId);
 
         uint256 buyingForTokenAmountWei = (_exchangeRateWei *
             _buyingTokenAmountWei) / 10 ** 18;
diff --git a/contracts/SpectrrData.sol b/contracts/SpectrrData.sol
index 4808127..db4ea19 100644
--- a/contracts/SpectrrData.sol
+++ b/contracts/SpectrrData.sol
@@ -5,14 +5,14 @@ pragma solidity >=0.4.22 <0.9.0;
 /// @author Supergrayfly
 /// @notice Defines and initializes the data for the SpectrrCore Contract
 contract SpectrrData {
-    /// @notice The minimum collateral to debt ratio allowing a liquidation
-    uint256 public constant MIN_RATIO_LIQUIDATION = 13 * 10 ** 17;
+    /// @notice The minimum collateral to debt ratio allowing a liquidation (1.25%)
+    uint256 public constant MIN_RATIO_LIQUIDATION = 125 * 10 ** 16;
 
-    /// @notice The collateral to debt ratio when the value of the collateral is equal to the value of the debt.
+    /// @notice The collateral to debt ratio when the value of the collateral is equal to the value of the debt (1%)
     uint256 public constant RATIO_LIQUIDATION_IS_LOSS = 1 * 10 ** 18;
 
-    /// @notice The initial collateral to debt ratio needed to create an offer.
-    uint256 public constant RATIO_COLLATERAL_TO_DEBT = 16 * 10 ** 17;
+    /// @notice The initial collateral to debt ratio needed to create an offer (1.5%)
+    uint256 public constant RATIO_COLLATERAL_TO_DEBT = 15 * 10 ** 17;
 
     /** @dev Number of existing sale offers, initialized as 0 in the beggining,
         and incremented by one at every sale offer creation.
@@ -45,19 +45,19 @@ contract SpectrrData {
 
     /// @dev SaleOffer struct, containing all the data composing a sale offer.
     struct SaleOffer {
-        OfferStatus offerStatus; //0
-        OfferLockState offerLockState; //1
-        uint256 offerId; //2
-        uint256 selling; //3
-        uint256 sellingFor; //4
-        uint256 collateral; //5
-        uint256 repayInSeconds; //6
-        uint256 timeAccepted; //7
-        uint8 sellingId; //8
-        uint8 sellingForId; //9
-        uint8 collateralId; //10
-        address seller; //11
-        address buyer; //12
+        OfferStatus offerStatus;
+        OfferLockState offerLockState;
+        uint256 offerId;
+        uint256 selling;
+        uint256 sellingFor;
+        uint256 collateral;
+        uint256 repayInSeconds;
+        uint256 timeAccepted;
+        uint8 sellingId;
+        uint8 sellingForId;
+        uint8 collateralId;
+        address seller;
+        address buyer;
     }
 
     /// @dev BuyOffer struct, containing all the data composing a buy offer.
diff --git a/contracts/SpectrrManager.sol b/contracts/SpectrrManager.sol
index 9972e36..d922e84 100644
--- a/contracts/SpectrrManager.sol
+++ b/contracts/SpectrrManager.sol
@@ -34,7 +34,7 @@ contract SpectrrManager is Ownable {
     }
 
     /// @notice Event emitted when a new token is added
-    event NewToken(
+    event NewTokenAdded(
         uint8 tokenId,
         string tokenName,
         address tokenAddress,
@@ -42,7 +42,7 @@ contract SpectrrManager is Ownable {
     );
 
     /// @notice Event emitted when the fee address is changed
-    event FeeAddressChanged(address newAddress, uint256 timestamp);
+    event FeeAddressChanged(address newAddress);
 
     /// @notice Adds a token to the array of tokens tradable by this contract
     /// @dev Only callable by owner
@@ -71,7 +71,12 @@ contract SpectrrManager is Ownable {
 
         tokens[id] = token;
 
-        emit NewToken(id, _tokenName, _tokenAddress, _chainlinkOracleAddress);
+        emit NewTokenAdded(
+            id,
+            _tokenName,
+            _tokenAddress,
+            _chainlinkOracleAddress
+        );
     }
 
     /// @notice Changes the fee address
@@ -79,7 +84,6 @@ contract SpectrrManager is Ownable {
     /// @param _newFeeAddress The new fee address
     function changeFeeAddress(address _newFeeAddress) external onlyOwner {
         feeAddress = _newFeeAddress;
-
-        emit FeeAddressChanged(_newFeeAddress, block.timestamp);
+        emit FeeAddressChanged(_newFeeAddress);
     }
 }
diff --git a/contracts/SpectrrPrices.sol b/contracts/SpectrrPrices.sol
index 3da31c6..dab726f 100644
--- a/contracts/SpectrrPrices.sol
+++ b/contracts/SpectrrPrices.sol
@@ -16,7 +16,7 @@ contract SpectrrPrices {
 
         (, int256 tokenPrice, , , ) = priceFeed.latestRoundData();
 
-        require(tokenPrice > 0, "Price is negative");
+        require(tokenPrice > 0, "Negative price");
 
         return tokenPrice;
     }
diff --git a/contracts/SpectrrCore.sol b/contracts/SpectrrCore.sol
index fdc8bea..d730a48 100644
--- a/contracts/SpectrrCore.sol
+++ b/contracts/SpectrrCore.sol
@@ -14,12 +14,12 @@ import "./SpectrrUtils.sol";
     This contract does not allow selling/buying a token for the same token. 
     Also, the collateral token chosen in a buy offer can not be the same than the repayment token.
     For example, one could make the following buy offer:
-        Buy 1 BTC for 69,000$ (assuming a current BTC price of 68,500$), pledge 1.8 times the repayment amount in collateral (here, 1.8 BTC), 
+        Buy 1 BTC for 69,000$ (assuming a current BTC price of 68,500$), pledge 1.5 times the repayment amount in collateral (here, 1.5 BTC), 
         and specify a repayment period of 69 days. After that, let us say that that someone accepts the offer by sending 1 BTC to the buyer.
         Assuming that the price of BTC reaches 70,000$ when the debt is repaid,
         the buyer would then make a profit of 70,000$ - 69,000$ = 1000$, after selling the 1 BTC bought earlier.
         On the other hand, the seller will receive 69,000$, and would have made a profit of 69,000$ - 68,500$ = 500$.
-        It can be noted that in our case, the seller would have made more profit holding the BTC.
+        It can be noted that in our case, the seller would have made more profit just holding the BTC.
 */
 /** @custom:extra The contract was voluntarily made this way in order for it to align with the principles of Islamic finance.
     In the latter, some prohibitions include dealing with interest, 
@@ -54,9 +54,7 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
     ) external nonReentrant returns (uint256) {
         checkIsPositive(_sellingTokenAmountWei);
         checkIsPositive(_exchangeRateWei);
-        checkTokenIdInRange(_sellingTokenId);
-        checkTokenIdInRange(_sellingForTokenId);
-        checkTokenIdNotSame(_sellingForTokenId, _sellingTokenId);
+        checkTokensIdNotSame(_sellingForTokenId, _sellingTokenId);
 
         transferSenderToContract(
             msg.sender,
@@ -117,7 +115,7 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
 
         checkOfferIsOpen(offer.offerStatus);
         checkAddressNotSender(offer.seller);
-        checkTokenIdNotSame(_collateralTokenId, offer.sellingId);
+        checkTokensIdNotSame(_collateralTokenId, offer.sellingId);
 
         uint256 collateralTokenAmount = getCollateral(
             offer.sellingFor,
@@ -360,10 +358,8 @@ contract SpectrrCore is SpectrrUtils, EIP712, ReentrancyGuard {
     ) external nonReentrant returns (uint256) {
         checkIsPositive(_buyingTokenAmountWei);
         checkIsPositive(_exchangeRateWei);
-        checkTokenIdInRange(_buyingTokenId);
-        checkTokenIdInRange(_buyingForTokenId);
-        checkTokenIdNotSame(_buyingTokenId, _buyingForTokenId);
-        checkTokenIdNotSame(_collateralTokenId, _buyingTokenId);
+        checkTokensIdNotSame(_buyingTokenId, _buyingForTokenId);
+        checkTokensIdNotSame(_collateralTokenId, _buyingTokenId);
 
         uint256 buyingForTokenAmountWei = (_exchangeRateWei *
             _buyingTokenAmountWei) / 10 ** 18;
diff --git a/contracts/SpectrrData.sol b/contracts/SpectrrData.sol
index 4808127..db4ea19 100644
--- a/contracts/SpectrrData.sol
+++ b/contracts/SpectrrData.sol
@@ -5,14 +5,14 @@ pragma solidity >=0.4.22 <0.9.0;
 /// @author Supergrayfly
 /// @notice Defines and initializes the data for the SpectrrCore Contract
 contract SpectrrData {
-    /// @notice The minimum collateral to debt ratio allowing a liquidation
-    uint256 public constant MIN_RATIO_LIQUIDATION = 13 * 10 ** 17;
+    /// @notice The minimum collateral to debt ratio allowing a liquidation (1.25%)
+    uint256 public constant MIN_RATIO_LIQUIDATION = 125 * 10 ** 16;
 
-    /// @notice The collateral to debt ratio when the value of the collateral is equal to the value of the debt.
+    /// @notice The collateral to debt ratio when the value of the collateral is equal to the value of the debt (1%)
     uint256 public constant RATIO_LIQUIDATION_IS_LOSS = 1 * 10 ** 18;
 
-    /// @notice The initial collateral to debt ratio needed to create an offer.
-    uint256 public constant RATIO_COLLATERAL_TO_DEBT = 16 * 10 ** 17;
+    /// @notice The initial collateral to debt ratio needed to create an offer (1.5%)
+    uint256 public constant RATIO_COLLATERAL_TO_DEBT = 15 * 10 ** 17;
 
     /** @dev Number of existing sale offers, initialized as 0 in the beggining,
         and incremented by one at every sale offer creation.
@@ -45,19 +45,19 @@ contract SpectrrData {
 
     /// @dev SaleOffer struct, containing all the data composing a sale offer.
     struct SaleOffer {
-        OfferStatus offerStatus; //0
-        OfferLockState offerLockState; //1
-        uint256 offerId; //2
-        uint256 selling; //3
-        uint256 sellingFor; //4
-        uint256 collateral; //5
-        uint256 repayInSeconds; //6
-        uint256 timeAccepted; //7
-        uint8 sellingId; //8
-        uint8 sellingForId; //9
-        uint8 collateralId; //10
-        address seller; //11
-        address buyer; //12
+        OfferStatus offerStatus;
+        OfferLockState offerLockState;
+        uint256 offerId;
+        uint256 selling;
+        uint256 sellingFor;
+        uint256 collateral;
+        uint256 repayInSeconds;
+        uint256 timeAccepted;
+        uint8 sellingId;
+        uint8 sellingForId;
+        uint8 collateralId;
+        address seller;
+        address buyer;
     }
 
     /// @dev BuyOffer struct, containing all the data composing a buy offer.
diff --git a/contracts/SpectrrManager.sol b/contracts/SpectrrManager.sol
index 9972e36..d922e84 100644
--- a/contracts/SpectrrManager.sol
+++ b/contracts/SpectrrManager.sol
@@ -34,7 +34,7 @@ contract SpectrrManager is Ownable {
     }
 
     /// @notice Event emitted when a new token is added
-    event NewToken(
+    event NewTokenAdded(
         uint8 tokenId,
         string tokenName,
         address tokenAddress,
@@ -42,7 +42,7 @@ contract SpectrrManager is Ownable {
     );
 
     /// @notice Event emitted when the fee address is changed
-    event FeeAddressChanged(address newAddress, uint256 timestamp);
+    event FeeAddressChanged(address newAddress);
 
     /// @notice Adds a token to the array of tokens tradable by this contract
     /// @dev Only callable by owner
@@ -71,7 +71,12 @@ contract SpectrrManager is Ownable {
 
         tokens[id] = token;
 
-        emit NewToken(id, _tokenName, _tokenAddress, _chainlinkOracleAddress);
+        emit NewTokenAdded(
+            id,
+            _tokenName,
+            _tokenAddress,
+            _chainlinkOracleAddress
+        );
     }
 
     /// @notice Changes the fee address
@@ -79,7 +84,6 @@ contract SpectrrManager is Ownable {
     /// @param _newFeeAddress The new fee address
     function changeFeeAddress(address _newFeeAddress) external onlyOwner {
         feeAddress = _newFeeAddress;
-
-        emit FeeAddressChanged(_newFeeAddress, block.timestamp);
+        emit FeeAddressChanged(_newFeeAddress);
     }
 }
diff --git a/contracts/SpectrrPrices.sol b/contracts/SpectrrPrices.sol
index 3da31c6..dab726f 100644
--- a/contracts/SpectrrPrices.sol
+++ b/contracts/SpectrrPrices.sol
@@ -16,7 +16,7 @@ contract SpectrrPrices {
 
         (, int256 tokenPrice, , , ) = priceFeed.latestRoundData();
 
-        require(tokenPrice > 0, "Price is negative");
+        require(tokenPrice > 0, "Negative price");
 
         return tokenPrice;
     }
diff --git a/contracts/SpectrrUtils.sol b/contracts/SpectrrUtils.sol
index 23a8829..80bc453 100644
--- a/contracts/SpectrrUtils.sol
+++ b/contracts/SpectrrUtils.sol
@@ -7,7 +7,7 @@ import "./SpectrrManager.sol";
 
 /// @title SpectrrUtils
 /// @author Supergrayfly
-/// @notice This contract handles 'secondary' functions, such as transferring tokens and calculating collateral.
+/// @notice This contract handles 'secondary' functions, such as transferring tokens and calculating collateral tokens.
 contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
     /// @notice Gets the current block timestamp
     /// @return uint256 The current block timestamp
@@ -19,7 +19,7 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
     /// @param _tokenId Id of the token we want the interface
     /// @return IERC20 The Interface of the token
     function getITokenFromId(uint8 _tokenId) public view returns (IERC20) {
-        require(_tokenId <= tokenCount && _tokenId > 0, "Token id not valid");
+        checkTokenIdInRange(_tokenId);
         return tokens[_tokenId].Itoken;
     }
 
@@ -27,13 +27,11 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
     /// @param _tokenId Id of the token we want the price
     /// @return uint256 The price of the token
     function tokenIdToPrice(uint8 _tokenId) public view returns (uint256) {
-        require(_tokenId <= tokenCount && _tokenId > 0, "Token id not valid");
-
-        uint256 price = uint256(
-            getChainlinkPrice(tokens[_tokenId].chainlinkOracleAddress)
-        );
-
-        return price * 10 ** (18 - tokens[_tokenId].decimals);
+        checkTokenIdInRange(_tokenId);
+        return
+            uint256(
+                getChainlinkPrice(tokens[_tokenId].chainlinkOracleAddress)
+            ) * 10 ** (18 - tokens[_tokenId].decimals);
     }
 
     /// @notice Calculates the liquidation price of the collateral token
@@ -44,6 +42,7 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint8 _amountForTokenId,
         uint256 _liquidationLimit
     ) public view returns (uint256) {
+        checkTokenIdInRange(_amountForTokenId);
         return
             (_liquidationLimit *
                 _amountForTokenWei *
@@ -59,6 +58,7 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint8 _collateralTokenId,
         uint256 _liquidationLimit
     ) public view returns (uint256) {
+        checkTokenIdInRange(_collateralTokenId);
         return
             (_collateralTokenAmountWei *
                 tokenIdToPrice(_collateralTokenId) *
@@ -72,8 +72,11 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint256 _amountTokenWei,
         uint8 _amountTokenId
     ) internal {
-        IERC20 token = getITokenFromId(_amountTokenId);
-        token.transferFrom(_sender, address(this), _amountTokenWei);
+        getITokenFromId(_amountTokenId).transferFrom(
+            _sender,
+            address(this),
+            _amountTokenWei
+        );
     }
 
     /// @notice Transfers tokens from this contract to the sender of the tx
@@ -83,8 +86,7 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint256 _amountTokenWei,
         uint8 _amountTokenId
     ) internal {
-        IERC20 token = getITokenFromId(_amountTokenId);
-        token.transfer(_sender, _amountTokenWei);
+        getITokenFromId(_amountTokenId).transfer(_sender, _amountTokenWei);
     }
 
     /// @notice Handles the transfer of the collateral, fee, and amount bought
@@ -101,17 +103,17 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint256 _amountTokenWei,
         uint8 _amountTokenId
     ) internal {
-        IERC20 token = getITokenFromId(_collateralTokenId);
-
-        token.transferFrom(_sender, address(this), _collateralTokenAmountWei);
-
+        getITokenFromId(_collateralTokenId).transferFrom(
+            _sender,
+            address(this),
+            _collateralTokenAmountWei
+        );
         transferFee(_collateralTokenAmountWei, _collateralTokenId, _sender);
-
         transferContractToSender(_sender, _amountTokenWei, _amountTokenId);
     }
 
     /// @notice Transfers token from the buyer to the seller of an offer
-    /// @ Only callable internally by this contract
+    /// @dev Only callable internally by this contract
     /// @param _sender Address sending the tokens
     /// @param _receiver Address receiving the tokens
     /// @param _amountTokenWei Amount to send
@@ -122,8 +124,11 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint256 _amountTokenWei,
         uint8 _amountTokenId
     ) internal {
-        IERC20 token = getITokenFromId(_amountTokenId);
-        token.transferFrom(_sender, _receiver, _amountTokenWei);
+        getITokenFromId(_amountTokenId).transferFrom(
+            _sender,
+            _receiver,
+            _amountTokenWei
+        );
     }
 
     /// @notice Calculates the collateral needed to create a buy offer or accept a sale offer
@@ -159,10 +164,11 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         if (_amountTokenWei == 0 || _collateralTokenAmountWei == 0) {
             return 0;
         } else {
-            uint256 ratio = (_collateralTokenAmountWei *
-                tokenIdToPrice(_collateralTokenId) *
-                10 ** 18) / (_amountTokenWei * tokenIdToPrice(_amountTokenId));
-            return ratio;
+            return
+                (_collateralTokenAmountWei *
+                    tokenIdToPrice(_collateralTokenId) *
+                    10 ** 18) /
+                (_amountTokenWei * tokenIdToPrice(_amountTokenId));
         }
     }
 
@@ -399,15 +405,14 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
         uint8 _amountTokenId,
         address _sender
     ) internal {
-        IERC20 token = getITokenFromId(_amountTokenId);
-        token.transferFrom(
+        getITokenFromId(_amountTokenId).transferFrom(
             _sender,
             feeAddress,
             (_amountTokenWei / FEE_PERCENT)
         );
     }
 
-    /// @notice Checks if token Id is a tradable tokens
+    /// @notice Checks if token Id is a tradable token
     /// @param _id Id of the token
     function checkTokenIdInRange(uint8 _id) internal view {
         require(_id > 0 && _id <= tokenCount, "Invalid Id");
@@ -433,9 +438,9 @@ contract SpectrrUtils is SpectrrPrices, SpectrrData, SpectrrManager {
 
     /// @notice Checks if id of two tokens are the same, reverts if true
     /// @param _id Id of first token
-    /// @param __id id of second token
-    function checkTokenIdNotSame(uint8 _id, uint8 __id) internal pure {
-        require(_id != __id, "Cannot be same token Id");
+    /// @param id_ id of second token
+    function checkTokensIdNotSame(uint8 _id, uint8 id_) internal pure {
+        require(_id != id_, "Cannot be same token Id");
     }
 
     /// @notice Checks if offer is open (i.e. not accepted or closed), reverts if false
